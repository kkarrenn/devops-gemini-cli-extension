# Publishing package distribution releases using GitHub Actions CI/CD workflows [Â¶](\#publishing-package-distribution-releases-using-github-actions-ci-cd-workflows "Link to this heading")

[GitHub Actions CI/CD](https://github.com/features/actions) allows you to run a series of commands
whenever an event occurs on the GitHub platform. One
popular choice is having a workflow thatâ€™s triggered by a
`push` event.
This guide shows you how to publish a Python distribution
whenever a tagged commit is pushed.
It will use the [pypa/gh-action-pypi-publish GitHub Action](https://github.com/marketplace/actions/pypi-publish) for
publishing. It also uses GitHubâ€™s [upload-artifact](https://github.com/actions/upload-artifact) and [download-artifact](https://github.com/actions/download-artifact) actions
for temporarily storing and downloading the source packages.

Attention

This guide _assumes_ that you already have a project that you know how to
build distributions for and _it lives on GitHub_. This guide also avoids
details of building platform specific projects. If you have binary
components, check out [cibuildwheel](../../key_projects/#cibuildwheel)â€™s GitHub Action examples.

## Configuring Trusted Publishing [Â¶](\#configuring-trusted-publishing "Link to this heading")

This guide relies on PyPIâ€™s [Trusted Publishing](https://docs.pypi.org/trusted-publishers/) implementation to connect
to [GitHub Actions CI/CD](https://github.com/features/actions). This is recommended for security reasons, since
the generated tokens are created for each of your projects
individually and expire automatically. Otherwise, youâ€™ll need to generate an
[API token](https://pypi.org/help/#apitoken) for both PyPI and TestPyPI. In case of publishing to third-party
indexes like [devpi](https://devpi.net/docs/devpi/devpi/latest/+doc/index.html "(in devpi v6.17)"), you may need to provide a
username/password combination.

Since this guide will demonstrate uploading to both
PyPI and TestPyPI, weâ€™ll need two trusted publishers configured.
The following steps will lead you through creating the â€œpendingâ€ publishers
for your new [PyPI project](../../glossary/#term-Project).
However it is also possible to add [Trusted Publishing](https://docs.pypi.org/trusted-publishers/) to any
pre-existing project, if you are its owner.

Attention

If you followed earlier versions of this guide, you
have created the secrets `PYPI_API_TOKEN` and `TEST_PYPI_API_TOKEN`
for direct PyPI and TestPyPI access. These are obsolete now and
you should remove them from your GitHub repository and revoke
them in your PyPI and TestPyPI account settings in case you are replacing your old setup with the new one.

Letâ€™s begin! ğŸš€

1. Go to [https://pypi.org/manage/account/publishing/](https://pypi.org/manage/account/publishing/).

2. Fill in the name you wish to publish your new
   [PyPI project](../../glossary/#term-Project) under
   (the `name` value in your `setup.cfg` or `pyproject.toml`),
   the GitHub repository ownerâ€™s name (org or user),
   and repository name, and the name of the release workflow file under
   the `.github/` folder, see [Creating a workflow definition](#workflow-definition).
   Finally, add the name of the GitHub Environment
   ( `pypi`) weâ€™re going set up under your repository.
   Register the trusted publisher.

3. Now, go to [https://test.pypi.org/manage/account/publishing/](https://test.pypi.org/manage/account/publishing/) and repeat
   the second step, but this time, enter `testpypi` as the name of the
   GitHub Environment.

4. Your â€œpendingâ€ publishers are now ready for their first use and will
   create your projects automatically once you use them
   for the first time.



   Note



   If you donâ€™t have a TestPyPI account, youâ€™ll need to
   create it. Itâ€™s not the same as a regular PyPI account.





   Attention



   For security reasons, you must require [manual approval](https://docs.github.com/en/actions/how-tos/managing-workflow-runs-and-deployments/managing-deployments/managing-environments-for-deployment#creating-an-environment)
   on each run for the `pypi` environment.


## Creating a workflow definition [Â¶](\#creating-a-workflow-definition "Link to this heading")

GitHub CI/CD workflows are declared in YAML files stored in the
`.github/workflows/` directory of your repository.

Letâ€™s create a `.github/workflows/publish-to-pypi.yml`
file.

Start it with a meaningful name and define the event that
should make GitHub run this workflow:

```
name: Publish Python ğŸ distribution ğŸ“¦ to PyPI and TestPyPI

on: push

```

## Checking out the project and building distributions [Â¶](\#checking-out-the-project-and-building-distributions "Link to this heading")

We will have to define two jobs to publish to PyPI
and TestPyPI respectively, and an additional job to
build the distribution packages.

First, weâ€™ll define the job for building the dist packages of
your project and storing them for later use:

```
jobs:
  build:
    name: Build distribution ğŸ“¦
    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v6
      with:
        persist-credentials: false
    - name: Set up Python
      uses: actions/setup-python@v6
      with:
        python-version: "3.x"

```

This will download your repository into the CI runner and then
install and activate the newest available Python 3 release.

And now we can build the dists from source and store them.
In this example, weâ€™ll use the `build` package.
So add this to the steps list:

```
    - name: Install pypa/build
      run: >-
        python3 -m
        pip install
        build
        --user
    - name: Build a binary wheel and a source tarball
      run: python3 -m build
    - name: Store the distribution packages
      uses: actions/upload-artifact@v5
      with:
        name: python-package-distributions
        path: dist/

```

## Defining a workflow job environment [Â¶](\#defining-a-workflow-job-environment "Link to this heading")

Now, letâ€™s add initial setup for our job that will publish to PyPI.
Itâ€™s a process that will execute commands that weâ€™ll define later.
In this guide, weâ€™ll use the latest stable Ubuntu LTS version
provided by GitHub Actions. This also defines a GitHub Environment
for the job to run in its context and a URL to be displayed in GitHubâ€™s
UI nicely. Additionally, it allows acquiring an OpenID Connect token
that the `pypi-publish` actions needs to implement secretless
Trusted Publishing to PyPI.

```
  publish-to-pypi:
    name: >-
      Publish Python ğŸ distribution ğŸ“¦ to PyPI
    if: startsWith(github.ref, 'refs/tags/')  # only publish to PyPI on tag pushes
    needs:
    - build
    runs-on: ubuntu-latest
    environment:
      name: pypi
      url: https://pypi.org/p/<package-name>  # Replace <package-name> with your PyPI project name
    permissions:
      id-token: write  # IMPORTANT: mandatory for trusted publishing

```

This will also ensure that the PyPI publishing workflow is only triggered
if the current commit is tagged.

## Publishing the distribution to PyPI [Â¶](\#publishing-the-distribution-to-pypi "Link to this heading")

Finally, add the following steps at the end:

```
    steps:
    - name: Download all the dists
      uses: actions/download-artifact@v6
      with:
        name: python-package-distributions
        path: dist/
    - name: Publish distribution ğŸ“¦ to PyPI
      uses: pypa/gh-action-pypi-publish@release/v1

```

This step uses the [pypa/gh-action-pypi-publish](https://github.com/pypa/gh-action-pypi-publish) GitHub
Action: after the stored distribution package has been
downloaded by the [download-artifact](https://github.com/actions/download-artifact) action, it uploads
the contents of the `dist/` folder into PyPI unconditionally.

Tip

Starting with version
[v1.11.0](https://github.com/pypa/gh-action-pypi-publish/releases/tag/v1.11.0),
[pypa/gh-action-pypi-publish](https://github.com/pypa/gh-action-pypi-publish) generates and uploads [**PEP 740**](https://peps.python.org/pep-0740/)-compatible
attestations for each distribution by default. No additional manual
signing steps are required.

## Separate workflow for publishing to TestPyPI [Â¶](\#separate-workflow-for-publishing-to-testpypi "Link to this heading")

Now, repeat these steps and create another job for
publishing to the TestPyPI package index under the `jobs`
section:

```
  publish-to-testpypi:
    name: Publish Python ğŸ distribution ğŸ“¦ to TestPyPI
    needs:
    - build
    runs-on: ubuntu-latest

    environment:
      name: testpypi
      url: https://test.pypi.org/p/<package-name>

    permissions:
      id-token: write  # IMPORTANT: mandatory for trusted publishing

    steps:
    - name: Download all the dists
      uses: actions/download-artifact@v6
      with:
        name: python-package-distributions
        path: dist/
    - name: Publish distribution ğŸ“¦ to TestPyPI
      uses: pypa/gh-action-pypi-publish@release/v1
      with:
        repository-url: https://test.pypi.org/legacy/

```

Tip

Requiring manual approvals in the `testpypi` GitHub Environment is typically unnecessary as itâ€™s designed to run on each commit to the main branch and is often used to indicate a healthy release publishing pipeline.

## The whole CI/CD workflow [Â¶](\#the-whole-ci-cd-workflow "Link to this heading")

This paragraph showcases the whole workflow after following the above guide.

Click here to display the entire GitHub Actions CI/CD workflow definition

```
name: Publish Python ğŸ distribution ğŸ“¦ to PyPI and TestPyPI

on: push

jobs:
  build:
    name: Build distribution ğŸ“¦
    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v6
      with:
        persist-credentials: false
    - name: Set up Python
      uses: actions/setup-python@v6
      with:
        python-version: "3.x"
    - name: Install pypa/build
      run: >-
        python3 -m
        pip install
        build
        --user
    - name: Build a binary wheel and a source tarball
      run: python3 -m build
    - name: Store the distribution packages
      uses: actions/upload-artifact@v5
      with:
        name: python-package-distributions
        path: dist/

  publish-to-pypi:
    name: >-
      Publish Python ğŸ distribution ğŸ“¦ to PyPI
    if: startsWith(github.ref, 'refs/tags/')  # only publish to PyPI on tag pushes
    needs:
    - build
    runs-on: ubuntu-latest
    environment:
      name: pypi
      url: https://pypi.org/p/<package-name>  # Replace <package-name> with your PyPI project name
    permissions:
      id-token: write  # IMPORTANT: mandatory for trusted publishing

    steps:
    - name: Download all the dists
      uses: actions/download-artifact@v6
      with:
        name: python-package-distributions
        path: dist/
    - name: Publish distribution ğŸ“¦ to PyPI
      uses: pypa/gh-action-pypi-publish@release/v1

  publish-to-testpypi:
    name: Publish Python ğŸ distribution ğŸ“¦ to TestPyPI
    needs:
    - build
    runs-on: ubuntu-latest

    environment:
      name: testpypi
      url: https://test.pypi.org/p/<package-name>

    permissions:
      id-token: write  # IMPORTANT: mandatory for trusted publishing

    steps:
    - name: Download all the dists
      uses: actions/download-artifact@v6
      with:
        name: python-package-distributions
        path: dist/
    - name: Publish distribution ğŸ“¦ to TestPyPI
      uses: pypa/gh-action-pypi-publish@release/v1
      with:
        repository-url: https://test.pypi.org/legacy/

```

## Thatâ€™s all, folks! [Â¶](\#that-s-all-folks "Link to this heading")

Now, whenever you push a tagged commit to your Git repository remote
on GitHub, this workflow will publish it to PyPI.
And itâ€™ll publish any push to TestPyPI which is useful for
providing test builds to your alpha users as well as making
sure that your release pipeline remains healthy!

Attention

If your repository has frequent commit activity and every push is uploaded
to TestPyPI as described, the project might exceed the
[PyPI project size limit](https://pypi.org/help/#project-size-limit).
The limit could be increased, but a better solution may constitute to
use a PyPI-compatible server like [pypiserver](../../key_projects/#pypiserver) in the CI for testing purposes.

Note

It is recommended to keep the integrated GitHub Actions at their latest
versions, updating them frequently.